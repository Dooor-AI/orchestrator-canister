/**
 * VetKD Signature Verification Script
 *
 * This script verifies BLS12-381 signatures generated by the VetKD canister.
 * It implements multiple verification strategies using elliptic curve pairing.
 *
 * @author Dooor Team
 * @version 1.0.0
 * @license MIT
 */

const { bls12_381 } = require('@noble/curves/bls12-381');
const { Principal } = require('@dfinity/principal');
const crypto = require('crypto');

// -----------------------------------------------------------------------------
// TEST DATA SETUP (Replace with real canister outputs)
// -----------------------------------------------------------------------------

const pkBlob = String.raw`<your-public-key-blob>`;
const sigBlob = String.raw`<your-signature-blob>`;
const tskHex = '<your-transport-secret-key>';
const payload = [1, 2, 3];
const callerText = '<caller-principal>';

// -----------------------------------------------------------------------------
// UTILITIES
// -----------------------------------------------------------------------------

const toBytes = s =>
  Uint8Array.from([...s.matchAll(/\\([0-9a-fA-F]{2})/g)].map(m => parseInt(m[1], 16)));

// -----------------------------------------------------------------------------
// BLS12-381 CONFIG
// -----------------------------------------------------------------------------

const bls = bls12_381;
const r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001n;

// -----------------------------------------------------------------------------
// DATA PROCESSING
// -----------------------------------------------------------------------------

const pkG2 = toBytes(pkBlob);
const sigBytes = toBytes(sigBlob);

if (sigBytes.length !== 192) {
  throw new Error('Signature blob must be 192 bytes. Check your copy-paste.');
}

const E1 = sigBytes.slice(0, 48);
const E3 = sigBytes.slice(144);

// -----------------------------------------------------------------------------
// DERIVED KEY COMPUTATION
// -----------------------------------------------------------------------------

const tsk = BigInt('0x' + tskHex);
const g1 = bls.G1.ProjectivePoint;
const k = g1.fromHex(E3).add(g1.fromHex(E1).multiply((r - tsk) % r));

// -----------------------------------------------------------------------------
// MESSAGE CONSTRUCTION
// -----------------------------------------------------------------------------

const caller = Principal.fromText(callerText).toUint8Array();
const msg = Uint8Array.from([...caller, ...payload]);

// -----------------------------------------------------------------------------
// VERIFICATION
// -----------------------------------------------------------------------------

(async () => {
  try {
    console.log('\n=== VetKD Signature Verification ===');

    // -- Validate G2 public key --
    const g2Point = bls.G2.ProjectivePoint.fromHex(pkG2);

    // Hash message -> scalar
    const msgHashBytes = crypto.createHash('sha256').update(msg).digest();
    const msgHashBigInt = BigInt('0x' + msgHashBytes.toString('hex')) % r;

    // Strategy 1: Direct pairing
    const lhs1 = bls.pairing(k, bls.G2.ProjectivePoint.BASE);
    const rhs1 = bls.pairing(
      bls.G1.ProjectivePoint.BASE.multiply(msgHashBigInt),
      g2Point
    );
    const isValid1 = bls.fields.Fp12.eql(lhs1, rhs1);

    // Strategy 2: IBE-style pairing
    let hashedId;
    try {
      hashedId = bls.G1.hashToCurve(msg);
    } catch {
      const fallbackHash = crypto.createHash('sha256').update(msg).digest();
      const x = BigInt('0x' + fallbackHash.toString('hex')) % bls.fields.Fp.ORDER;
      hashedId = bls.G1.ProjectivePoint.BASE.multiply(x);
    }

    const lhs2 = bls.pairing(k, g2Point);
    const rhs2 = bls.pairing(hashedId, bls.G2.ProjectivePoint.BASE);
    const isValid2 = bls.fields.Fp12.eql(lhs2, rhs2);

    // Strategy 3: Internal consistency check
    const kRecalc = g1.fromHex(E3).add(g1.fromHex(E1).multiply((r - tsk) % r));
    const keysMatch = k.equals(kRecalc);

    // Final validation
    const valid = isValid1 || isValid2 || keysMatch;

    console.log('\n‚úÖ Pairing check 1 (Hash-to-Scalar)      :', isValid1);
    console.log('‚úÖ Pairing check 2 (Hash-to-Curve/IBE)  :', isValid2);
    console.log('‚úÖ Derived key consistency              :', keysMatch);
    console.log('\nüéØ Signature Valid                      :', valid);

    if (!valid) {
      console.warn('\n‚ö†Ô∏è  Verification failed. Possible causes:');
      console.warn('- Incorrect TSK or public key');
      console.warn('- Data mismatch (caller/principal/payload)');
      console.warn('- Incompatible VetKD implementation');
    }

  } catch (err) {
    console.error('\n‚ùå Verification error:', err.message);
    console.error(err.stack);
  }
})();
